"""
Module for testing the whether certain bivariate polynomials remain irreducible when
specialized at roots of unity. The main references are
[1] R. Dvornicich and U. Zannier, 
    "Cyclotomic Diophantine problems (Hilbert irreducibility and invariant sets for 
    polynomial maps)", Duke Math J. 139 (2007), 527--554.
[2] C. Bertone, G. Ch\'{e}ze, and A. Galligo, 
    "Modular Las Vegas algorithms for polynomial absolute factorization",
    J. Symbolic Comput. 45 (2010), 1280--1295.
"""
from sage.all import Polyhedron, gcd, PolynomialRing, ZZ, LatticePolytope, QQ
import sage.symbolic.expression

def cyclotomic_change_of_variables(polynomial, reverse_order=False):
    """
    Given a bivariate polynomial f(X,Y), this returns the polynomial 
        g(X,Y) = X^(deg_X(f))*f(X+X^(-1),Y).
    The point is that g(X,Y) we're often actually interested in the irreducibility of f
    when X is evaluated at zeta_n + zeta_n^(-1) for zeta_n an nth root of unity, but
    the theorems of Dvornicich and Zannier apply to specializations at zeta_n. However,
    if g(zeta_n,Y) is irreducible over the relevant cyclotomic field, then
    f(zeta_n+zeta_n^(-1),Y) will be as well.

    Be careful that one wants to change the variables in the first coordinate. We can
    maybe improve this later to allow for changing the second coordinate.
    """
    ring = polynomial.parent()
    X, Y = ring.gens()
    degree = polynomial.degree(X)
    new_poly = ring(polynomial(X+X**(-1),Y)*X**(degree))
    return new_poly

def newton_polytope(polynomial, lattice=False):
    """
    Given a bivariate integer polynomial p(x,y) = \sum_{i,j}c_{i,j}x^iy^j, this is
    is the convex hull in RR^2 of all points (i,j) such that c_{i,j} != 0.
    The returned type is a Sage Polygon unless the lattice flag is True, in
    which case it's a Lattice polytope type.
    """
    if isinstance(polynomial, sage.symbolic.expression.Expression):
        polynomial = polynomial.polynomial(ZZ)
    D = polynomial.dict()
    points = list(D.keys())
    if lattice:
        temporary_points = []
        for point in points:
            temporary_points.append(tuple(point))
        points = temporary_points
        return LatticePolytope(points)
    polygon = Polyhedron(vertices=points)
    return polygon


def conditionC(polynomial):  # Maybe add an optional irreducibility check.
    set_to_take_GCD_of = set()
    polygon_vertices = newton_polytope(polynomial).vertices()
    for vertex in polygon_vertices:
        set_to_take_GCD_of.add(vertex()[0])
        set_to_take_GCD_of.add(vertex()[1])
    d = gcd(tuple(set_to_take_GCD_of))
    if d == 1:
        return True
    else:
        return False

def cyclotomically_irreducible(polynomial):
    """
    Combines the conditionC test for absolute irreducibility with D-Z's test for
    irreducibility at cyclotomic specializations. In particular, if f(X,Y) is a
    bivariate polynomial such that f(X^m,Y) is absolutely irreducible (one can weaken
    this) for each 1 <= m <= deg_Y(f), then f(zeta_n,Y) is irreducible over k^c, the
    composite of all extensions of k generated by roots of unity. This function tests
    each f(X^m, Y) using conditionC. The function returns all the m for which the
    polynomial fails conditionC. So it will return the empty list if D-Z's theorem
    applies.

    Be careful that one's variables are in the right order.
    """
    ring = polynomial.parent()
    X, Y = ring.gens()
    deg_Y = polynomial.degree(Y)
    bad_powers = list()
    for m in range(1, deg_Y+1):
        new_poly = polynomial(X**m,Y).change_ring(QQ)
        if not (new_poly.is_prime() and conditionC(new_poly)):
            bad_powers.append(m)
    return bad_powers