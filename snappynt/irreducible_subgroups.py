def within_epsilon(a, b, epsilon_coefficient=1):
    """
    I feel like Sage should probably have a way to do this anyway, but I was unable to
    find it. What this does is take in two number from fixed=precision fields and test
    whether they're within the smallest nonzero positive number representatble in both
    fields times the epsilon_coefficient. One can tweak the epsilon_coefficient to be
    more or less conservative (depending on the application) with equality testing.
    Note that setting the epsilon_coefficient to less than 1 might introduce some
    weirdness since you'll have a quantity smaller than the theoretically smallest
    representable quantity in the fixed precision fields. The idea, by the way, is that
    by increasing the epsilon_coefficient, one can be more sure that two numbers are in
    fact different. Of course the very notion of epsilon-nearness relies on some
    underlying metric, so if the elements lack an absolute value function, the function
    will fail.

    Also, this is used extensively in the irreducible_subgroups module, but is perhaps
    thematically better suited to living in another module.
    Aug-15 2020
    """
    base_field_a = a.parent().base()
    base_field_b = b.parent().base()
    if base_field_a.is_exact() and base_field_b.is_exact():
        epsilon = 0
    else:
        epsilon = max(base_field_a.epsilon(), base_field_b.epsilon())
    if abs(a - b) < epsilon_coefficient * epsilon:
        return True
    else:
        return False


def is_parabolic(element, epsilon_coefficient):
    """
    Tests whether an element has trace 2 using the within_epsilon method.  Actually it
    tests whether the element is within epsilon of 2 (see within_epsilon
    and generate_reducible_subgroup functions for more details). 
    """
    if within_epsilon(element, 2, epsilon_coefficient):
        return True
    else:
        return False


def generate_reducible_subgroup(g, h, epsilon_coefficient=10):
    """
    Tests whether the subgroup of  generated by g and h is irreducible. The function
    actually tests whether the trace of the commutator of g and h is less than epsilon_coeffient
    times epsilon from 2 where epsilon is the smallest nonzero quantity that the base field
    with specified precision can recognize.  This implies that the function might
    incorrectly say that two elements generate a reducible subgroup when their
    commutator has trace closer (but not equal) to 2 that the ambient precision.
    On the other hand, it will never certify that a subgroup is irreducible when it is
    not. 

    I'm not actually sure if there's a slicker way to test for equality or exactly
    the implementation details of equality testing in Sage's various rings.

    Also, this function as currently written is a bittle amusingly short, but I'm going
    to leave it because it will be called elsewhere, and it lets me change how
    irreducibility is certified in the future.
    Aug-13 2020
    """
    if within_epsilon(a.commutator(b).trace(), 2, epsilon_coefficient):
        return True
    else:
        return False
