"""
This module gives custom JSON encoding and decoding for ManifoldAP objects. The purpose
is to eventually have a test bench that can be verified for accuracy then quickly loaded
to compare future versions of this package against.

The core invariants computed in the ManifoldAP module are the two trace fields, and the
two quaternion algebras. Another invariant are the denominators, though these are often
computed alongside the (noninvariant) trace field. We want this encoding and decoding to
be somewhat flexible to allow for later information to be added. 

We should add that we don't intend for the JSON representations to be totally minimal:
since JSON is human readable, we include some extra information for quick reference.
"""

import json
import ManifoldAP
import QuaternionAlgebraNF
from sage.rings.number_field.number_field import is_NumberField
from sage.all import CC, radical, ZZ, PolynomialRing, QQ, NumberField, RR, RealField

class FieldEncoder(json.JSONEncoder):
    """
    Returns a JSON dict for fields as they come to us from Kleinian groups. This will
    intentionally raise an exception if there's no specified embedding when gen_embedding
    gets called. This has some shortcomings for use with totally general number field.
    In particular, the fields encoded should be generated by a single element. Of course
    every number field is generated by a primitive element, but they're not always 
    presented that way. Also, relative extensions will probably break things.
    """

    def default(self, field):
        if is_NumberField(field):
            if field.gen_embedding() is None:
                raise AttributeError("There is no specified embedding")
            d = {
                "defining polynomial": str(field.defining_polynomial()),
                "generator name": str(field.gen()),
                "numerical root": {
                    "real part": float(CC(field.gen_embedding()).real_part()),
                    "imaginary part": float(CC(field.gen_embedding()).imag_part()),
                },
                "discriminant": int(field.discriminant()),
                "signature": str(field.signature()),
            }
            return d
        else:
            return json.JSONEncoder(self, field)

def string_to_poly(s, variable='x'):
    """
    Takes a string representation s of a polynomial and makes it a polynomial that sage
    can recognize. The polynomial should have rational coefficients. If the coefficients
    are (rational) integers, then the returned polynomial will be recognized by sage as
    an polynomial in ZZ[x]. The variable keyword argument needs to match the variable
    that appears in the string representation.
    """
    x = variable
    try:
        ring = PolynomialRing(ZZ, x)
        poly = ring(s)
    except TypeError:
        ring = PolynomialRing(QQ, x)
        poly = ring(s)
    return poly

def fix_ideal_string(s):
    """
    Takes a string representing an ideal in a number field and returns a list of strings
    that sage can parse correctly. Sometimes sage won't interpret the strings correctly.
    For example, in K=Q(sqrt2), we have
    sage: K.ideal("(2,sqrt2)")
    Fractional ideal (4)
    
    But of course we really want the ideal generated by sqrt2. For that example, this
    function returns ["2", "sqrt2"], which can be parsed by sage correctly:
    sage:K.ideal(["sqrt2", "2"])
    Fractional ideal (sqrt2)
    """
    if s[0] == "(": s = s[1:]
    if s[-1] == ")": s = s[0:-1]
    return s.split(",")

class FieldDecoder(json.JSONDecoder):
    def decode(self, text):
        raw_dict = json.JSONDecoder().decode(text)
        defining_poly = string_to_poly(raw_dict["defining polynomial"])
        real= raw_dict["numerical root"]["real part"]
        imag = raw_dict["numerical root"]["imaginary part"]
        numerical_root = CC(real, imag)
        field = NumberField(defining_poly, raw_dict["generator name"], embedding=numerical_root)
        return field

class QuaternionAlgebraEncoder(json.JSONEncoder):
    """
    Returns a JSON dictionary for Quaternion Algebras over number fields. Since computing
    ramification sets can actually be computationally expensive in general, we have a
    special field to record the dyadic ramification (which tends to be the hard ones).
    """

    def default(self, algebra):
        if isinstance(algebra, QuaternionAlgebraNF.QuaternionAlgebraNF):
            a, b = algebra.invariants()
            d = {
                "base field" : FieldEncoder().default(algebra.base_ring()),
                "Hilbert symbol": {"first entry": str(a), "second entry": str(b),},
                "ramification": {
                    "dyadic ramification": [
                        str(element.gens())
                        for element in sorted(
                            [
                                ideal
                                for ideal in algebra.ramified_finite_places()
                                if radical(ideal.absolute_norm()) == 2
                            ],
                            key=lambda ideal: ideal.residue_class_degree(),
                        )
                    ],
                    "nondyadic ramification": [
                        str(element.gens())
                        for element in sorted(
                            [
                                ideal
                                for ideal in algebra.ramified_finite_places()
                                if radical(ideal.absolute_norm()) != 2
                            ],
                            key=lambda x: radical(x.absolute_norm()),
                        )
                    ],
                    "residue characteristics": [int(element) for element in algebra.ramified_residue_characteristics().elements()],
                    "real ramification": [
                        str(place.im_gens()[0])
                        for place in algebra.ramified_real_places()
                    ],
                },
            }
            return d
        else:
            return json.JSONEncoder(self, algebra)

def place_finder(field, s):
    """
    For a field field and a string s representing a real place, finds the real place of
    the field closest to the string. The string should be a string that looks like a
    real number.
    """
    number = RealField(106)(s)
    places = field.real_places()
    return min(places, key=lambda place : abs(number-place.im_gens()[0]))

class QuaternionAlgebraDecoder(json.JSONDecoder):
    """
    Decoding a JSON encoded QuaternionAlgebraNF. The point is to not recompute the
    ramification data for two reasons. The first is that some of finite ramification
    can be expensive (especially the dyadic places). The second is that we want to test
    against previous calculations.
    """
    def decode(self, text):
        raw_dict = json.JSONDecoder(text).decode(text)
        ramification_dict = raw_dict["ramification"]
        field = FieldDecoder().decode(raw_dict["base field"])
        a = field(raw_dict["Hilbert symbol"]["first entry"])
        b = field(raw_dict["Hilbert symbol"]["second entry"])
        algebra = QuaternionAlgebraNF.QuaternionAlgebraNF(field, a, b, compute_ramification=False)
        ramified_real_places = {place_finder(field, s) for s in ramification_dict["real ramification"]}
        
class ManifoldAP_Encoder(json.JSONEncoder):
    def default(self, mfld):
        d = {
            "name": str(mfld),
            "volume": float(mfld.volume()),
            "quaternion algebra": QuaternionAlgebraEncoder().default(
                mfld.quaternion_algebra()
            ),
            "invariant quaternion algebra": QuaternionAlgebraEncoder().default(
                mfld.invariant_quaternion_algebra()
            ),
            "denominators": {
                "ideals": [
                    str(element)
                    for element in sorted(
                        [ideal.gens() for ideal in mfld.denominators()],
                        key=lambda ideal: radical(ideal.absolute_norm()),
                    )
                ],
                "residue characteristics": sorted(
                    [
                        int(residue_char)
                        for residue_char in mfld.denominator_residue_characteristics()
                    ]
                ),
            },
            "arithmetic" : mfld.is_arithmetic()
        }
        return d

