"""
This module gives custom JSON encoding and decoding for ManifoldAP objects. The purpose
is to eventually have a test bench that can be verified for accuracy then quickly loaded
to compare future versions of this package against.

The core invariants computed in the ManifoldAP module are the two trace fields, and the
two quaternion algebras. Another invariant are the denominators, though these are often
computed alongside the (noninvariant) trace field. We want this encoding and decoding to
be somewhat flexible to allow for later information to be added. 

We should add that we don't intend for the JSON representations to be totally minimal:
since JSON is human readable, we include some extra information for quick reference.
"""

import json
import ManifoldAP
import QuaternionAlgebraNF
from sage.rings.number_field.number_field import is_NumberField
from sage.all import CC, radical, ZZ, PolynomialRing, QQ, NumberField, RR, RealField
from collections import Counter

class FieldEncoder(json.JSONEncoder):
    """
    Returns a JSON dict for fields as they come to us from Kleinian groups. This will
    intentionally raise an exception if there's no specified embedding when gen_embedding
    gets called. This has some shortcomings for use with totally general number field.
    In particular, the fields encoded should be generated by a single element. Of course
    every number field is generated by a primitive element, but they're not always 
    presented that way. Also, relative extensions will probably break things. However,
    as far as I'm aware, there's no reason trace fields should be relative extensions.
    """
    def default(self, field):
        if is_NumberField(field):
            if field.gen_embedding() is None:
                raise AttributeError("There is no specified embedding")
            d = {
                "defining polynomial": str(field.defining_polynomial()),
                "generator name": str(field.gen()),
                "numerical root": {
                    "real part": float(CC(field.gen_embedding()).real_part()),
                    "imaginary part": float(CC(field.gen_embedding()).imag_part()),
                },
                "discriminant": int(field.discriminant()),
                "signature": str(field.signature()),
            }
            return d
        else:
            return json.JSONEncoder(self, field)

def string_to_poly(s, variable='x'):
    """
    Takes a string representation s of a polynomial and makes it a polynomial that sage
    can recognize. The polynomial should have rational coefficients. If the coefficients
    are (rational) integers, then the returned polynomial will be recognized by sage as
    an polynomial in ZZ[x]. The variable keyword argument needs to match the variable
    that appears in the string representation. This will sometimes work with 
    """
    x = variable
    try:
        ring = PolynomialRing(ZZ, x)
        poly = ring(s)
    except TypeError:
        ring = PolynomialRing(QQ, x)
        poly = ring(s)
    return poly

def fix_ideal_string(s):
    """
    Takes a string representing an ideal in a number field and returns a list of strings
    that sage can parse correctly. Sometimes sage won't interpret the strings correctly.
    For example, in K=Q(sqrt2), we have
    sage: K.ideal("(2,sqrt2)")
    Fractional ideal (4)
    
    But of course we really want the ideal generated by sqrt2. For that example, this
    function returns ["2", "sqrt2"], which can be parsed by sage correctly:
    sage:K.ideal(["sqrt2", "2"])
    Fractional ideal (sqrt2)
    """
    if s[0] == "(": s = s[1:]
    if s[-1] == ")": s = s[0:-1]
    return s.split(",")

def dict_to_field(d):
    """
    Takes a Python/Sage dictionary to a number field object. The keys should be
    "defining polynomial"
    "generator name"
    "numerical root", which has
        "real part"
        "imaginary part"
    There can be other keys, but these must be present. The value for "defining
    polynomial" can possibly be a sage polynomial, but this is an "off label" use case.
    The point of having this be a separate function rather than just in the FieldDecoder
    class is to better handle nested JSON objects. E.g. ManifoldAP objects have fields
    associated to them, but when we decode ManifoldAP database objects, the field
    information becomes a Python dictionary rather than encoded JSON.
    """
    d = {key.lower():d[key] for key in d}
    defining_poly = string_to_poly(d["defining polynomial"])
    real = d["numerical root"]["real part"]
    imag = d["numerical root"]["imaginary part"]
    numerical_root = CC(real, imag)
    field = NumberField(defining_poly, d["generator name"], embedding=numerical_root)
    return field

class FieldDecoder(json.JSONDecoder):
    def decode(self, text):
        raw_dict = json.JSONDecoder().decode(text)
        #defining_poly = string_to_poly(raw_dict["defining polynomial"])
        #real= raw_dict["numerical root"]["real part"]
        #imag = raw_dict["numerical root"]["imaginary part"]
        #numerical_root = CC(real, imag)
        #field = NumberField(defining_poly, raw_dict["generator name"], embedding=numerical_root)
        return dict_to_field(raw_dict)

class QuaternionAlgebraEncoder(json.JSONEncoder):
    """
    Returns a JSON dictionary for Quaternion Algebras over number fields. Since computing
    ramification sets can actually be computationally expensive in general, we have a
    special field to record the dyadic ramification (which tends to be the hard ones).
    """
    def default(self, algebra):
        if isinstance(algebra, QuaternionAlgebraNF.QuaternionAlgebraNF):
            a, b = algebra.invariants()
            d = {
                "base field" : FieldEncoder().default(algebra.base_ring()),
                "Hilbert symbol": {"first entry": str(a), "second entry": str(b),},
                "ramification": {
                    "dyadic ramification": [
                        str(element.gens())
                        for element in sorted(
                            [
                                ideal
                                for ideal in algebra.ramified_finite_places()
                                if radical(ideal.absolute_norm()) == 2
                            ],
                            key=lambda ideal: ideal.residue_class_degree(),
                        )
                    ],
                    "nondyadic ramification": [
                        str(element.gens())
                        for element in sorted(
                            [
                                ideal
                                for ideal in algebra.ramified_finite_places()
                                if radical(ideal.absolute_norm()) != 2
                            ],
                            key=lambda x: radical(x.absolute_norm()),
                        )
                    ],
                    "residue characteristics": {str(element): int(algebra._ramified_residue_characteristics[element]) for element in algebra._ramified_residue_characteristics},
                    "real ramification": [
                        str(place.im_gens()[0])
                        for place in algebra.ramified_real_places()
                    ],
                },
            }
            return d
        else:
            return json.JSONEncoder(self, algebra)

def real_place_finder(field, s):
    """
    For a field field and a string s representing a real place, finds the real place of
    the field closest to the string. The string should be a string that looks like a
    real number.
    """
    number = RealField(106)(s)
    places = field.real_places()
    return min(places, key=lambda place : abs(number-place.im_gens()[0]))

def dict_to_quaternion_algebra(d):
    """
    Converts a dictionary to a QuaternionAlgebraNF object. The main use case is decoding
    serialized JSON objects. However, it's good to have it a separate function for
    nested decodings. The dictionary needs to conform to the following interface. It
    should have keys and subkeys
    "base field"
        (see dict_to_field function for interface)
    "ramification"
        "real ramification"
        "nondyadic ramification"
        "dyadic ramification"
        "residue characteristics"
    "Hilbert symbol"
        "first entry"
        "second entry"
    The interface looks a bit complicated, but the primary usecase is decoding encoded
    quaternion algebras. If they are encoded using the QuaternionAlgebraEncoder class
    and then decoded using the default JSON decoder, the original quaternion algebra
    will be recovered. E.g.
    F = NumberField(x^2-2,"z", embedding=1.4)
    QA = QuaternionAlgebraNF.QuaternionAlgebraNF(F, F.gen(), F.gen() - 5)
    s = json.dumps(QA, cls=json_encoder.QuaternionAlgebraEncoder)
    d = json.loads(s)
    QAPrime = dict_to_quaternion_algebra(d)
    QA.is_isomorphic(QAPrime) # Should return True.
    """
    ramification_dict = d["ramification"]
    field = dict_to_field(d["base field"])
    a = field(d["Hilbert symbol"]["first entry"])
    b = field(d["Hilbert symbol"]["second entry"])
    algebra = QuaternionAlgebraNF.QuaternionAlgebraNF(field, a, b, compute_ramification=False)
    ramified_real_places = {real_place_finder(field, s) for s in ramification_dict["real ramification"]}
    ramified_nondyadic_places = {field.ideal(fix_ideal_string(s)) for s in ramification_dict["nondyadic ramification"]}
    ramified_dyadic_places = {field.ideal(fix_ideal_string(s)) for s in ramification_dict["dyadic ramification"]}
    algebra._ramified_real_places = ramified_real_places
    algebra._ramified_finite_places = ramified_nondyadic_places | ramified_dyadic_places
    algebra._ramified_residue_characteristics = Counter({int(key) : ramification_dict["residue characteristics"][key] for key in ramification_dict["residue characteristics"]})
    algebra._ramified_dyadic_places_computed = True
    return algebra

class QuaternionAlgebraDecoder(json.JSONDecoder):
    """
    Decoding a JSON encoded QuaternionAlgebraNF. See the dict_to_quaternion_algebra
    function for details.
    """
    def decode(self, text):
        text_dict = json.JSONDecoder().decode(text)
        algebra = dict_to_quaternion_algebra(text_dict)
        return algebra

class ManifoldAP_Encoder(json.JSONEncoder):
    def default(self, mfld):
        d = {
            "name": str(mfld),
            "volume": float(mfld.volume()),
            "quaternion algebra": QuaternionAlgebraEncoder().default(
                mfld.quaternion_algebra()
            ),
            "invariant quaternion algebra": QuaternionAlgebraEncoder().default(
                mfld.invariant_quaternion_algebra()
            ),
            "denominators": {
                "ideals": [
                    str(element.gens())
                    for element in sorted(
                        list(mfld.denominators()),
                        key=lambda ideal: radical(ideal.absolute_norm()),
                    )
                ],
                "residue characteristics": sorted(
                    [
                        int(residue_char)
                        for residue_char in mfld.denominator_residue_characteristics()
                    ]
                ),
            },
            "arithmetic" : mfld.is_arithmetic()
        }
        return d

def dict_to_manifold(d):
    """
    For similar reason as the other dict_to functions, we have a standalone function
    that converts the Python dictionary returned by the default JSON encoding to a
    ManifoldAP object. The necessary interface is
    "name"
    "quaternion algebra"
    "invariant quaternion algebra"
    "denominators"
    It's worth pointing out that the trace fields are part of the quaternion algebras.
    Also, since computing volume is cheap, we just recompute it when we recreate the
    manifold so that we don't lose precision. We also recompute the residue
    characteristics, but this may or may not be faster. The idea is we don't want to
    break things if one day we decide that the residue characteristics don't belong in
    the JSON object.
    """
    mfld = ManifoldAP.ManifoldAP(d["name"], delay_computations=True)
    quaternion_algebra = dict_to_quaternion_algebra(d["quaternion algebra"])
    invariant_quaternion_algebra = dict_to_quaternion_algebra(d["invariant quaternion algebra"])
    trace_field = quaternion_algebra.base_ring()
    invariant_trace_field = invariant_quaternion_algebra.base_ring()
    denominators = {trace_field.ideal(fix_ideal_string(s)) for s in d["denominators"]["ideals"]}
    mfld._trace_field, mfld._invariant_trace_field = trace_field, invariant_trace_field
    mfld._quaternion_algebra, mfld._invariant_quaternion_algebra = quaternion_algebra, invariant_quaternion_algebra
    mfld._denominators = denominators
    mfld._denominator_residue_characteristics = mfld.denominator_residue_characteristics()
    return mfld

class ManifoldAP_Decoder(json.JSONDecoder):
    """
    Converts a serialized JSON object to a ManifoldAP object.
    """
    def decode(self, text):
        pass

def convert_json_array_to_dict(json_array):
    """
    By a json_array, we mean a JSON object all of whose elements are encoded ManifoldAP
    JSON objects. The output of this function is a Python dictionary whose keys are the
    names of the manifolds (as specified in their JSON objects) and whose values are
    ManifoldAP objects.
    """
    pass